PIZZA

String -  is a sequence of characters, that can be stored in a variable
Tuple - stores a collection of data, like a list, but is immutable â€“ once created, the tuple's elements cannot be changed
Object -  is a grouping of data (variables) and operations that can be performed on that data (functions or methods)
Abstraction - occurs when a user interacts with an object at a high level, allowing lower-level internal details to remain hidden
Class keyword - can be used to create a user-defined type of object containing groups of related variables and functions
Attributes - determines the data and behavior of the class
Instance method - a function defined within a class
Class object - acts as a factory that creates instance objects
Class attribute - is shared among all instances of that class
Instance attribute -  can be unique to each instance
Class interface - consists of the methods that a programmer calls to create, modify, or access a class instance
Class customization - is the process of defining how a class should behave for some common operations
Memory deallocation - is the act of freeing the memory that stores variables or objects in a program
Reference count - is an integer counter that represents how many variables reference an object
Recursive function - a function that calls itself
Base case - every recursive function must have a case that returns a value without performing a recursive call
Algorithm - describes a sequence of steps to solve a computacional problem or perform a calculation
Computationla problem - specifies an input, a questions about the input that can be answered using a computer, and the desired output
NP Complete - set of problems which no known efficient algorithms exist


Unambiguity: A perfect algorithm is defined as unambiguous, which means that its instructions should be clear and straightforward
Finiteness: An algorithm must be finite. Finiteness in this context means that the algorithm should have a limited number of instructions, i.e., the instructions should be countable
Effectiveness: Because each instruction in an algorithm affects the overall process, it should be adequate
Language independence: An algorithm must be language-independent, which means that its instructions can be implemented in any language and produce the same results
Scalability: It aids in your understanding of scalability. When you have a sizable real-world problem, you must break it down into small steps to analyze it quickly
Modularity: This feature was perfectly designed for the algorithm if you are given a problem and break it down into small-small modules or small-small steps, which is a basic definition of an algorithm
Correctness: An algorithm's correctness is defined as when the given inputs produce the desired output, indicating that the algorithm was designed correctly
Maintainability: It means that the algorithm should be designed in a straightforward, structured way so that when you redefine the algorithm, no significant changes are made to the algorithm
Functionality: It takes into account various logical steps to solve a real-world problem
Robustness: Robustness refers to an algorithm's ability to define your problem clearly
Simplicity: If an algorithm is simple, it is simple to understand
Extensibility: Your algorithm should be extensible if another algorithm designer or programmer wants to use it
Branch and Bound Algorithm: Only integer programming problems can be solved using the branch and bound algorithm. This method divides all feasible solution sets into smaller subsets. These subsets are then 							evaluated further to find the best solution
Priori Analysis: In this context, priori analysis refers to the theoretical analysis of an algorithm performed before implementing the algorithm. Before implementing the algorithm, various factors such as processor  		       speed, which does not affect the implementation, can be considered
Posterior Analysis: In this context, posterior analysis refers to a practical analysis of an algorithm. The algorithm is implemented in any programming language to perform the experimental research. This analysis 			    determines how much running time and space is required

Garbage collection: the automatic process of freeing up space in a computer's memory by removing data that is no longer required or in use
Reference count: an integer counter that represents how many variables reference an object
			   a programming technique of storing the number of references, pointers, or handles to a resource, such as an object, a block of memory, disk space, and others. 
			   In garbage collection algorithms, reference counts may be used to deallocate objects that are no longer needed
Memory allocation: the process of setting aside sections of memory in a program to be used to store variables, and instances of structures and classes
Memory deallocation: is the act of freeing the memory that stores variables or objects in a program
Linked allocation: solves all problems of contiguous allocation. With linked allocation, each file is a linked list of disk blocks; The disk blocks may be scattered anywhere on the disk. The directory contains a pointer 			     to the first and last blocks of the file
Sequential allocation - is a simple and widely studied mecha- nism to allocate indivisible items in turns to agents according to a pre-specified picking sequence of agents. At each turn, the current agent in the 					   picking sequence picks its most pre- ferred item among all items having not been allocated yet
Oject constructor:  a special type of function called to create an object. It prepares the new object for use, often accepting arguments that the constructor uses to set required member variables
Identity: unique identifier that describes the object 
"//" - symbol for floored division




len() -  built-in function can be used to find the length of a string (and any other sequence type)


Greedy algorithm - is an algorithm that, when presented with a list of options, chooses the option that is optimal at that point in time






An instantiation operation is performed by "calling" the class, using parentheses like a function call as in my_time = Time(). An instantiation operation creates an instance, which is an individual object of
the given class. An instantiation operation automatically calls the __init__ method defined in the class definition. A method is a function defined within a class

my_var = my_str[len(my_str) -1]


** heap list 
** preorder traversal 










9:17


